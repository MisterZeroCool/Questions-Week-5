# <img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">Вопросы: Неделя 5!<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">

# Содержание
# [Clean Architecture](#сleana_architecture)
   - [Q1a](#q1a) Принципы Clean Architecture
   - [Q2a](#q2a) На какие слои делится Clean Architecture?


# [Feature Module Arch](#feature_module_arch)

   - [Q3a](#q3a) Что такое Многомодульная архитектура?
   - [Q4a](#q4a) На какие части можно разделить многомодульную архитектуру?
   - [Q5a](#q5a) Чего позволяет добиться многомодульная архитектура?
   - [Q6a](#q6a) Какие типы модулей могут быть в многомодульной архитектуре?
   
# [Архитектура](#Архитектура)
   
   - [Q7a](#q7a) Архитектура мобильных приложений
   - [Q8a](#q8a) Что дает архитектура?
     
# [MVP](#mvp)

   - [Q9a](#q9a) Что такое MVP?
   - [Q10a](#q10a) На какие слои делится MVP?
   - [Q11a](#q11a) Moxy
   - [Q12a](#q12a) Преимущества Moxy
   - [Q13a](#q13a) Что такое ViewState в Moxy?
   - [Q14a](#q14a) Какие пулы потоков может создавать Executors?
   - [Q15a](#q15a) Аннотации Moxy
   - [Q16a](#q16a) Стратегии Moxy
   - [Q17a](#q17a) Когда применять данные стратегии?
   - [Q18a](#q18a) Преимущества MVP

# [MVVM](#mvvm)

   - [Q19a](#q19a) Что такое MVVM? 
   - [Q20a](#q20a) ViewModel
   - [Q21a](#q21a) Жизненный цикл ViewModel
   - [Q22a](#q22a) Задачи ViewModelStoreOwner
   - [Q23a](#q23a) ViewModelStore
   - [Q24a](#q24a) Можно ли передавать context или ссылку на View во ViewModel?
   - [Q25a](#q25a) Каким образом должны общаться View и ViewModel?
   - [Q26a](#q26a) Преимущества MVVM


  
# Clean Architecture<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">

### Q1a
### Принципы Clean Architecture
-независимость от фреймворков-архитектура не должна полагаться на существование какой-либо библиотеки.

-тестируемость-бизнес-логика должна быть тестируемой без любых внешних элементов вроде интерфейса,  базы данных, сервера или любого другого элемента.

-независимость от интерфейса-интерфейс должен легко изменяться и не требовать изменения остальной системы.

-независимость от базы данных-ваша бизнес-логика не должна быть привязана к конкретным базам данным.

-независимость от любого внешнего агента-ваша бизнес-логика не должна знать вообще ничего о внешнем мире.

[Содержание](#содержание)

### Q2a
### На какие слои делится Clean Architecture?
-Presentation Layer (пользовательский интерфейс)-UI и все что с ним связано, может содержать фрагменты, модели представления, адаптеры, действия и т.д. Также может содержать указатель служб для управления зависимостями, но при желании вы можете использовать Dagger.

-Domain Layer (логика функционирования)-содержит определения логики функционирования приложения, модели данных сервера, абстрактное определение репозиториев и определение сценариев использования. Это простой, чистый модуль kotlin (независимый от android и других слоев).

-Data Layer (модель данных)-содержит реализацию абстрактных определений Domain Layer. Содержит репозитории и реализации источников данных, определение базы данных и ее DAO, определения сетевых API, некоторые средства преобразования для конвертации моделей сетевого API в модели базы данных и наоборот, или конвертации данных модели данных из Data в Domain слои.

[Содержание](#содержание)

# Feature Module Arch<img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExbnluOG4xdGlpeWxwYnFhM3Bjc2Z3dzN5eDhhaThza2N0Ym9wOGUxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/zECASgodRMZ5QAbRao/giphy.gif" width="30px">

### Q3a
### Что такое Многомодульная архитектура?
-архитектура построенная на взаимодействии нескольких модулей (Kotlin).

[Содержание](#содержание)

### Q4a
### На какие части можно разделить многомодульную архитектуру?

-Feature(фичер)-модуль, который делится на два модуля, Feature-Api и Feature-Impl.

-Feature-Api-набор Entity и интерфейсов. Интерфейсы-абстракция зависимостей, которые модуль может отдать наружу, так и требования которые необходимы самому модулю.

-Feature-Impl-реализация логики, которая не доступна наружу.

[Содержание](#содержание)

### Q5a
### Чего позволяет добиться многомодульная архитектура?
-ускорить сборку проекта. Gradle способен собирать проект в многопоточном режиме.

-модули изолированы друг от друга и легко тестируемы.

-отличная структуризация проекта.

-удобно и быстро создавать B2B решения, обобщать логику под разные устройства (tv, watch и т.д.).

[Содержание](#содержание)

### Q6a
### Какие типы модулей могут быть в многомодульной архитектуре?
-Mobile-содержат все что относится к данному экрану, активити, фрагменты, диалоги и ресурсы.

-Core-интеракторы, Util классы, DAO, API классы для запроса в сеть.

[Содержание](#содержание)

### Q7a
### Архитектура мобильных приложений
-совокупность решений, как организовать программу. В нее входят: структурные элементы и интерфейсы, связи между выбранными элементами, общий стиль программы.

[Содержание](#содержание)

### Q8a
### Что дает архитектура?

-эффективность-приложение выполняет поставленные задачи и выполняет функции в любых условиях. Система производительна, надежна и справляется со всеми нагрузками.

-гибкость-выбранное решение легко менять, и ошибок становится меньше.  Можно изменить один элемент, и это не станет фатальным для других составляющих.

-расширяемость-в приложение можно добавлять сколько угодно функций, если потребуется.

-масштабируемость-время на разработку и дополнение уменьшается. Хорошая архитектура позволяет направить разработку в несколько параллельных потоков.

-тестируемость-приложение легко тестируется, а значит, уменьшается число ошибок и увеличивается его надежность.

-повторное использование-элементы и структуру можно использовать в других проектах.

-понятность-код должен быть понятен как можно большему количеству людей. Хорошая архитектура позволяет новичкам быстро разобраться в проекте.

[Содержание](#содержание)

## ⭐MVP

### Q9a
### Что такое MVP?
-шаблон, используемый для проектирования архитектуры мобильного приложения.

[Содержание](#содержание)

### Q10a
### На какие слои делится MVP?
-Model-представляет собой интерфейс, отвечающий за управление данными (включая кэширование данных и управление базами данных) приложения и "хранение" его бизнес-логики. В Android приложении Model часто выполняет REST API или база данных API.

-View–это класс, отвечающий за отображение данных. В Android-приложениях View – это обычно Activity или Fragment. Кроме того View слушает пользовательские ивенты и делегирует их обработку в Presenter.

-Presenter–это класс, который имеет ссылки и на View, и на Model, и расположен между ними. Presenter отвечает за обработку ивентов, приходящих из View, получение данных из Model и обновление View c полученными данными.

[Содержание](#содержание)

### Q11a
### Moxy
-библиотека, которая помогает использовать шаблон MVP при работе с Android-приложением. Помогает решить проблемы жц при переворотах без шаблонного кода.

[Содержание](#содержание)

### Q12a
### Преимущества Moxy
-поддержка и разработка библиотеки.

-поддержка фичей Kotlin вроде val presenter by moxyPresenter {component.myPresenter} и presenterScope для корутин.

-автоматическое восстановление состояния View.

-автоматическая увязка с жизненным циклом (отсутствие утечек активити).

-обращения к View происходят через не-nullable viewState. Нет риска, что какая-то команда View потеряется.

-весь lifecycle экрана сводится к двум коллбэкам презентера-onFirstViewAttach(в некоторых случаях лучше onAttachView) и onDestroy.

-время разработки экранов сокращается-не нужно писать лишний код для обработки lifecycle и сохранения состояния.

[Содержание](#содержание)

### Q13a
### Что такое ViewState в Moxy?
-прослойка между View и Presenter. Отвечает за то, чтобы каждая View всегда выглядела именно так, как того хочет Presenter. Хранит в себе список команд, которые были переданы из Presenter во View. И когда "новая" View присоединяется к Presenter, ViewState автоматически применяет к ней все команды, которые Presenter выдавал раньше.


[Содержание](#содержание)

### Q14a
### Аннотации Moxy
-@InjectPresenter-аннотация для управления жц Presenter.

-@InjectViewState-аннотация для привязывания ViewState к Presenter.

-@StateStrategyType-аннотация для управления стратегией добавления и удаления команды из очереди команд во ViewState.

-@GenerateViewState-аннотация для генерации кода ViewState для определенного интерфейса View.

[Содержание](#содержание)

### Q15a
### Стратегии Moxy
-AddToEndStrategy-выполнить команду и добавить команду в конец очереди.

-AddToEndSingleStrategy-выполнить команду, добавить ее в конец очереди и удалить все ее предыдущие экземпляры.

-SingleStateStrategy-выполнить команду, очистить очередь и добавить в нее команду.

-SkipStrategy-выполнить команду. Не меняет стека ViewState. Команда применяется ко View, только в том случае, если она находится в активном состоянии.

-OneExecuteStrategy-выполнить команду при первой возможности. Команда применяется ко View, если она находится в активном состоянии, иначе добавляется в конец очереди ViewState.

-для каждой стратегии при пересоздании View ко View последовательно применяются команды из очереди ViewState.

[Содержание](#содержание)

### Q16a  
### Когда применять данные стратегии?
-AddToEndStrategy-применяется, когда нужно последовательно применить несколько команд, которые должны повторно примениться при пересоздании View.

-AddToEndSingleStrategy-применяется, когда команда должна применяться при пересоздании View не более одного раза.

-SingleStateStrategy-применяется, когда нам не важен результат команд отработавших до нее.

-SkipStrategy-применяется, когда нам необходимо выполнить некоторое действие, прямо сейчас и только в случае, если имеется View в активном состоянии.

-OneExecuteStrategy-применяется, когда нам необходимо выполнить некоторое действие при первом появлении View в активном состоянии.
 
[Содержание](#содержание)

### Q17a   
### Преимущества MVP
-Presenter не пересоздается при пересоздании Activity (упрощает работу с многопоточностью).

-автоматизация полного восстановления того, что видит пользователь при пересоздании Activity.
-возможность из одного Presenter менять сразу несколько View.
    
[Содержание](#содержание)

### Q18a
### Назовите минусы MVP
-циклическая зависимость между View и Presenter.

-Presenter предоставляет методы для обработки жизненного цикла View.

-раздутый интерфейс View.

-сложно сохранять состояние.

  
[Содержание](#содержание)

## ⭐MVVM

### Q19a
### Что такое MVVM? 
-шаблон, используемый для проектирования архитектуры мобильного приложения. Ключевой особенностью паттерна MVVM является то, что ни один компонент (Model, View, ViewModel) не знает о другом явно. Эти компоненты взаимодействуют между собой за счет механизма связывания данных, который реализуется средствами той или иной системы.

-при изменении данных во ViewModel, меняются данные и во View, и при изменении данных во View, меняются данные во ViewModel. Это позволяет не хранить явные ссылки на View во ViewModel и наоборот, а также держать эти компоненты очень слабо связными, что удобно при тестировании.
  
[Содержание](#содержание)

### Q20a
### ViewModel
-класс, который соединяет View и Model. ViewModel подписана на обновления Model, а View подписана на обновления ViewModel. При этом ViewModel не имеет явной ссылки на View. Подписки реализуются через паттерн Observer.

[Содержание](#содержание)

### Q21a   
### Жизненный цикл ViewModel
-onCleared-очистка ресурсов перед уничтожением ViewModel. Вызывается после уничтожения активити или фрагмента (onDestroy).

[Содержание](#содержание)

### Q22a
### Задачи ViewModelStoreOwner
-сохранение ViewModel при смене конфигурации.

-вызывать ViewModelStore.clear() когда объекты уже не нужны.

[Содержание](#содержание)

### Q23a
### ViewModelStore
-содержит в себе HashMap<String,ViewModel>. Когда мы вызываем ViewModelProvider.get(), ViewModelProvider создает новую ViewModel и помещает в Map. Если она была уже создана, достает ее по Key. Не переживает смену конфигурации, т.к. хранится в NonConfigurationInstances.
  
[Содержание](#содержание)

### Q24a
### Можно ли передавать context или ссылку на View во ViewModel?
-нет, ViewModel не должна ничего знать о View.

[Содержание](#содержание)

### Q25a
### Каким образом должны общаться View и ViewModel?
-необходимо использовать паттерн Observer, а именно LiveData или Observable из других библиотек. 

-можно использовать MutableStateFlow вместо LiveData. В этом случае LifeCycleExtensions предоставит нам множество удобных extension-ов для чтения состояния (lifecycleScope.launchWhenCreated, lifecycleScope.launchWhenStarted)

[Содержание](#содержание)

### Q26a
### Преимущества MVVM
-ViewModel сохраняются при изменении конфигурации, поэтому нет нужды в повторном запросе внешних источников данных (бд, сетевое хранилище) при повороте устройства.

-когда заканчивается длительная операция, observable во ViewModel обновляются. Не важно велось наблюдение за данными или нет.

-ViewModel не содержат ссылки на View, что снижает риск возникновения утечек памяти.


[Содержание](#содержание)

### Q27a
### 


[Содержание](#содержание)

